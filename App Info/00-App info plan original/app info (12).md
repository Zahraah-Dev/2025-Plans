

# **7\) إدارة الحالة (State Management)**

---

## **الفائدة**

* تنظيم تدفق البيانات داخل التطبيق بحيث تكون **الشاشات دائمًا متزامنة** مع حالة المستخدم (سلة، طلبات، جلسة…).  
* تقليل الأخطاء الناتجة عن فقدان البيانات أو عدم تحديث الواجهة.  
* تحسين تجربة الاستخدام (تحديث فوري – بدون ارتباك).

---

## **المطلوب من التنفيذ**

### **A) حالة المستخدم (Session/Auth State)**

* حفظ بيانات الجلسة بعد تسجيل الدخول (User ID, Token, Profile).  
* تحديث الحالة تلقائيًا عند انتهاء صلاحية التوكن → إعادة توجيه لشاشة تسجيل الدخول.  
* تحميل بيانات المستخدم (Profile, Addresses) بمجرد نجاح تسجيل الدخول.

### **B) السلة (Cart State)**

* تتبع العناصر المضافة (product\_id, variant\_id, qty, price\_at\_add).  
* تحديث الأسعار عند كل فتح للسلة أو عند الـCheckout (مع مقارنة السعر الحالي).  
* مزامنة السلة مع الخادم عند تسجيل الدخول أو الخروج (User ↔ Guest Cart).  
* إظهار حالة Loading/Empty/Error في الواجهة بشكل موحّد.

### **C) الطلبات (Orders State)**

* حفظ آخر الطلبات (Recent Orders) مع الحالة الحالية لكل طلب.  
* تحديث الحالة عند وصول إشعار أو Refresh يدوي.  
* إمكانية استعراض الطلبات حتى بدون إنترنت (من الكاش).

### **D) التفضيلات والإعدادات (Preferences/Settings State)**

* اللغة (ar/en).  
* وضع الإشعارات (مفعّل/متوقف).  
* طريقة الدفع المفضلة (COD/Prepaid).  
* تفضيلات واجهة مثل آخر فلترة أو ترتيب منتجات.

---

## **معايير القبول (Definition of Done)**

* **Session State**: يتم تسجيل الدخول والخروج وتحديث الجلسة بشكل متسق في جميع الشاشات.  
* **Cart State**: عند إضافة منتج يظهر فورًا في كل شاشة مرتبطة، وتحديث السعر عند التغيير.  
* **Orders State**: شاشة الطلبات تعرض آخر حالة بدون الحاجة لإعادة الدخول.  
* **Preferences State**: تغييرات الإعدادات تظهر مباشرة وتُحفظ للجلسة التالية.  
* كل حالة مدعومة بـ **States قياسية**: `idle`, `loading`, `success`, `error`.

---

## **التسليمات**

1. **State Containers** (ViewModel/Bloc/Riverpod) لكل من: User, Cart, Orders, Preferences.  
2. **تعريف الحالات (State Classes)** تشمل: idle, loading, success(data), error(message).  
3. **مستند يوضح Events الأساسية** (AddToCart, RemoveFromCart, RefreshOrders…).  
4. اختبارات Unit لـ Cart وOrders للتأكد أن الحالة تتغير بشكل صحيح.  
5. آلية مزامنة بين الكاش المحلي والخادم.

---

## **أخطاء يجب تجنبها**

* تخزين الحالة في الواجهة مباشرة (Widget/Screen) → يسبب فقدان البيانات عند إعادة تحميل الشاشة.  
* عدم تحديث السعر عند Checkout → يسبب تعارض مع الخادم.  
* السماح بوجود أكثر من حالة متناقضة (مثال: المستخدم مسجّل دخول لكن الـSession State فارغ).  
* تجاهل إدارة Empty/Error States → يخلق تجربة مربكة للمستخدم.

# **التسليمات – إدارة الحالة (State Management)**

1. **State Containers**  
   * إنشاء حاويات حالة (ViewModel / Bloc / Riverpod Provider) لكل مجال رئيسي:  
     * المستخدم (User State)  
     * السلة (Cart State)  
     * الطلبات (Orders State)  
     * التفضيلات (Preferences State)  
2. **تعريف الحالات (State Classes)**  
   * كل حاوية تحتوي حالات قياسية:  
     * `idle` (بدون بيانات بعد)  
     * `loading` (جاري التنفيذ)  
     * `success(data)` (تم التنفيذ مع بيانات)  
     * `error(message)` (فشل مع رسالة)

3. **مستند Events الأساسية**  
   * قائمة بالأحداث التي تغيّر الحالة، مثل:  
     * `AddToCart` – إضافة منتج للسلة  
     * `RemoveFromCart` – إزالة منتج من السلة  
     * `RefreshOrders` – تحديث قائمة الطلبات  
     * `UpdatePreferences` – تعديل الإعدادات  
4. **اختبارات Unit**  
   * بناء اختبارات لوحدة Cart وOrders للتحقق من:  
     * إضافة/إزالة عناصر تغيّر الحالة بشكل صحيح.  
     * تحديث الطلبات يظهر النتيجة الصحيحة.  
5. **آلية مزامنة الكاش مع الخادم**  
   * عند توفر إنترنت: تحديث الحالة من الخادم.  
   * عند عدم توفر إنترنت: استخدام الكاش المحلي.  
   * عند تسجيل الدخول أو الخروج: دمج السلة (Guest ↔ User) ومزامنة البيانات.


---

## 🏠 **Back to Home | العودة للرئيسية**

[← Back to Main Index | العودة للفهرس الرئيسي](../../../index.html)

---
